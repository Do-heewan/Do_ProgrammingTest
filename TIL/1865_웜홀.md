# [Gold III] ì›œí™€ - 1865 

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/1865)

![ì›œí™€ - 1865](https://github.com/user-attachments/assets/57849d60-142b-4049-a420-0b0d6942d664)

### ğŸ—ï¸ì•Œê³ ë¦¬ì¦˜ ë¶„ë¥˜
- ìµœë‹¨ê²½ë¡œ
- ë²¨ë§Œ-í¬ë“œ

---

<br>

## ğŸ’»ë¬¸ì œ ì •ì˜

Nê°œì˜ ì§€ì ì´ ì¡´ì¬í•˜ëŠ” ë§ˆì„ì—ì„œ, í•œ ì§€ì ì—ì„œ ì¶œë°œí•˜ì—¬ ì›œí™€ì„ í†µí•´ ì‹œì‘ ì§€ì ìœ¼ë¡œ ëŒì•„ì™”ì„ ë•Œ, ì¶œë°œ ì‹œê°„ë³´ë‹¤ ì´ì „ ì‹œê°„ëŒ€ë¡œ ëŒì•„ì˜¨ ê²½ìš° "YES"ë¥¼ ì¶œë ¥í•˜ê³  ì•„ë‹ˆë©´ "NO"ë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œì´ë‹¤.

ì¦‰, ì£¼ì–´ì§„ ë§ˆì„ì„ ê·¸ë˜í”„ë¡œ í‘œí˜„í•˜ì˜€ì„ ë•Œ, ì–´ëŠ í•œ ì •ì ì—ì„œ ë¶€í„° ì‚¬ì´í´ì´ ë°œìƒí•˜ê³ , ê·¸ ì‚¬ì´í´ì´ ë¬´í•œí•œ ìŒìˆ˜ ì‚¬ì´í´ì„ ê°€ì§€ëŠ”ì§€ë¥¼ ì°¾ëŠ” ë¬¸ì œì´ë‹¤.

<br>

## ğŸ’¡ì ‘ê·¼ ë° ì„¤ê³„

ì‚¬ì´í´ ë°œìƒ ë° ìŒìˆ˜ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ê¸° ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•œë‹¤.

<br>

### âœï¸ì•Œê³ ë¦¬ì¦˜ í’€ì´
``` python
def bellman_ford(start):
    # ì‹œì‘ ë…¸ë“œ ê±°ë¦¬ ì´ˆê¸°í™”
    distance[start] = 0
    # ì „ì²´ ë…¸ë“œ ë°˜ë³µ
    for i in range(N):
        # ë§¤ ë°˜ë³µë§ˆë‹¤ ëª¨ë“  ê°„ì„  í™•ì¸
        for j in range(2*M+W):
            curr_node = edge[j][0]
            next_node = edge[j][1]
            edge_cost = edge[j][2]

            # í˜„ì¬ ê°„ì„ ì„ ê±°ì³ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì´ë™í•˜ëŠ” ê±°ë¦¬ê°€ ì§§ì€ ê²½ìš°
            if (distance[next_node] > distance[curr_node] + edge_cost):
                distance[next_node] = distance[curr_node] + edge_cost

                # N-1 ë²ˆì§¸ì—ì„œ ê°’ì´ ê°±ì‹ ëœë‹¤ë©´ ìŒìˆ˜ ìˆœí™˜ì´ ì¡´ì¬
                if (i == N - 1):
                    return True

    return False
```

ê¸°ì¡´ì˜ ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ë³€í˜•í•˜ì˜€ë‹¤.

ëª¨ë“  ì •ì ì— ëŒ€í•´ì„œ ëª¨ë“  ê°„ì„ ì„ í™•ì¸í•œë‹¤. ê·¸ë¦¬ê³  ê° ì •ì ì— ëŒ€í•´ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ distance ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•œë‹¤.

ì´ ê³¼ì •ì„ N-1ë²ˆ ë°˜ë³µí•˜ê²Œ ë˜ëŠ”ë°, (N = ì •ì ì˜ ê°œìˆ˜) ë§ˆì§€ë§‰ ë°˜ë³µì—ì„œ ìµœë‹¨ ê²½ë¡œ ê°’ì— ë³€í™”ê°€ ìƒê¸´ë‹¤ë©´, ì´ëŠ” ìŒì˜ ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤ëŠ” ëœ»ì´ ëœë‹¤.

<br>

### ğŸ—’ï¸ì „ì²´ ì½”ë“œ
```python
# 1865 ì›œí™€

T = int(input())

INF = 1_000_000_000

def bellman_ford(start):
    # ì‹œì‘ ë…¸ë“œ ê±°ë¦¬ ì´ˆê¸°í™”
    distance[start] = 0
    # ì „ì²´ ë…¸ë“œ ë°˜ë³µ
    for i in range(N):
        # ë§¤ ë°˜ë³µë§ˆë‹¤ ëª¨ë“  ê°„ì„  í™•ì¸
        for j in range(2*M+W):
            curr_node = edge[j][0]
            next_node = edge[j][1]
            edge_cost = edge[j][2]

            # í˜„ì¬ ê°„ì„ ì„ ê±°ì³ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì´ë™í•˜ëŠ” ê±°ë¦¬ê°€ ì§§ì€ ê²½ìš°
            if (distance[next_node] > distance[curr_node] + edge_cost):
                distance[next_node] = distance[curr_node] + edge_cost

                # N-1 ë²ˆì§¸ì—ì„œ ê°’ì´ ê°±ì‹ ëœë‹¤ë©´ ìŒìˆ˜ ìˆœí™˜ì´ ì¡´ì¬
                if (i == N - 1):
                    return True

    return False

for _ in range(T):
    N, M, W = map(int, input().split())

    edge = []
    distance = [INF for _ in range(N+1)]

    for _ in range(M):
        S, E, T = map(int, input().split())
        edge.append([S, E, T])
        edge.append([E, S, T])

    # ì›œí™€ ì •ë³´ (Tê°€ ìŒìˆ˜)
    for _ in range(W):
        S, E, T = map(int, input().split())
        edge.append([S, E, -T])

    if bellman_ford(1): # ì‹œì‘ì ì€ ì˜ë¯¸ ì—†ìŒ
        print("YES")
    else:
        print("NO")
```

---

### [[Python] 1865 - ì›œí™€](https://do-heewan.tistory.com/152)